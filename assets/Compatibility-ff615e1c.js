var E=Object.defineProperty;var l=(c,e,t)=>e in c?E(c,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):c[e]=t;var a=(c,e,t)=>(l(c,typeof e!="symbol"?e+"":e,t),t);import{j as L}from"./jsx-runtime-94f6e698.js";import{r as p}from"./index-8db94870.js";const n=class{};let s=n;a(s,"Link"),a(s,"useLocation"),a(s,"useLayoutEffect",p.useLayoutEffect),a(s,"injectDependencies",(e,{location:t,link:h})=>{switch(e){case"next":{const u=h,f=t;n.Link=function({to:o,...i}){return L.jsx(u,{...i,href:o})},n.useLocation=()=>{const r=f(),{asPath:o,query:i}=r,[y,d]=o.split("?");return{...r,pathname:y,search:d&&Object.keys(i).length?`?${d}`:""}},n.useLayoutEffect=p.useEffect;break}case"react":{const u=h,f=t;n.Link=function(o){return L.jsx(u,{...o})},n.useLocation=f;break}}});try{s.useLayoutEffect.displayName="Compatibility.useLayoutEffect",s.useLayoutEffect.__docgenInfo={description:"The signature is identical to `useEffect`, but it fires synchronously after all DOM mutations.\nUse this to read layout from the DOM and synchronously re-render. Updates scheduled inside\n`useLayoutEffect` will be flushed synchronously, before the browser has a chance to paint.\n\nPrefer the standard `useEffect` when possible to avoid blocking visual updates.\n\nIf youâ€™re migrating code from a class component, `useLayoutEffect` fires in the same phase as\n`componentDidMount` and `componentDidUpdate`.",displayName:"Compatibility.useLayoutEffect",props:{}}}catch{}export{s as C};
//# sourceMappingURL=Compatibility-ff615e1c.js.map
